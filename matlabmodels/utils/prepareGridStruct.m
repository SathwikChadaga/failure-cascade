function [mpc, capacityVector, adjacencyMatrix] = prepareGridStruct(mpc, flowType)

mpc.branch = mpc.branch(:,1:13);
mpc.gen    = mpc.gen(:,1:21);
mpc.bus    = mpc.bus(:,1:13);

%% Reindex Nodes
% Node indices in mpc are not ordered.
% For our purpose, it is convinient if they are ordered.
% So, we reindex nodes to values taking from 1 to N,
% where N is the total number of nodes
mpc = reindexNodes(mpc);

%% Merge Overlapping Lines
% Some lines in mpc have multipple entries
% i.e. the edges have same start and end nodes but different capacity values
% To address these overlapping links, we merge them by adding their capacity values
mpc = mergeOverlappingLines(mpc);

%% Rebalance Power Values
% The total power grenerated and power consumed is not balanced by default.
% We balance it by uniformaly distributing the total excess generated power
% among all consumer nodes.
mpc = rebalancePower(mpc);

%% Address Missing Capacity Data
% In some power systems, there are transmission lines whose capacity
% data is not given. For these transmission lines, we regard they will
% not fail by assigning their capacity to be large enough (specificially 9900).
[mpc, capacityVector] = missingCapacityValues(mpc, flowType);

%% Get adjaceny matrix from power grid topology
adjacencyMatrix = getAdjacencyMatrix(mpc);

%% Tracking indices 
% Add extra 4 columns to branch to store solved power flow values.
% And add another extra column to keep track of this starting line indices
% as line indices might change in later time steps as lines start failing 
numLines = size(mpc.branch, 1);
mpc.branch = [mpc.branch, zeros(size(mpc.branch,1),4)];
mpc.branch = [mpc.branch, (1:numLines)'];
mpc.numInitialLines = numLines;

end

%% Helper Functions
function mpc = reindexNodes(mpc)

% Reindex values in mpc.bus to values from 1 to N and
% remember old node indices to reindex mpc.gen and mp.branch later
bus = mpc.bus;
nodeIndices_new = zeros(size(bus,1), 1);
nodeIndices_old = zeros(size(bus,1), 1);
for ii = 1:size(bus,1)
    nodeIndices_new(ii) = ii;
    nodeIndices_old(ii) = bus(ii,1);
end
bus(:,1) = nodeIndices_new;
bus      = sortrows(bus, 1);
mpc.bus  = bus;

% Apply reindexing to mpc.gen accordingly
gen = mpc.gen;
for ii = 1:size(gen,1)
    gen(ii,1) = nodeIndices_new(gen(ii,1) == nodeIndices_old);
end
gen = sortrows(gen,1);
mpc.gen = gen;

% Apply reindexing to mpc.branch accordingly
branch = mpc.branch;
for ii=1:size(branch,1)
    branch(ii,1) = nodeIndices_new(branch(ii,1) == nodeIndices_old);
    branch(ii,2) = nodeIndices_new(branch(ii,2) == nodeIndices_old);
end
mpc.branch = branch;

end

function mpc = mergeOverlappingLines(mpc)
% find edges who have multiple entries and add theri capacity values
branch = mpc.branch;
for ii = 1:size(branch,1)
    for jj = ii+1:size(branch,1)
        if (branch(ii,1) == branch(jj,1) && branch(ii,2) == branch(jj,2)) ...
                || (branch(ii,1) == branch(jj,2) && branch(ii,2) == branch(jj,1))
            branch(ii,6) = branch(ii,6) + branch(jj,6);
            branch(jj,:) = 0;
        end
    end
end

% remove the second copy and return
branch(branch(:,1) == 0,:) = [];
mpc.branch = branch;
end

function mpc = rebalancePower(mpc)

% mpc.bus contains the power consumed by each node
% mpc.gen contains the power generated by each node
powerInjected_consume = mpc.bus(:,3);
powerInjected_supply  = zeros(size(powerInjected_consume,1),1);
powerInjected_supply(mpc.gen(:,1)) = mpc.gen(:,2);

% redistribute extra supplied power uniformly among all consumers
powerInj_vector = powerInjected_supply - powerInjected_consume;
powerInjected_consume = powerInjected_consume + mean(powerInj_vector);
mpc.bus(:,3) = powerInjected_consume;


end


function [mpc, capacityVector] = missingCapacityValues(mpc, flowType)

if(strcmp(flowType, 'dc'))
    [result, ~] = rundcpf_me(mpc);
elseif(strcmp(flowType, 'ac'))
    [result, ~] = runacpf_me(mpc);
end

% if capacity value is missing, set it to 9900
missingCapacityValue = 2*mean(abs(result.branch(:,14)));
capacityVector = mpc.branch(:,6);
for ii = 1:size(capacityVector,1)
    if capacityVector(ii,1) == 0
        % capacityVector(ii,1) = mpc.missingCapacityValues;
        % capacityVector(ii,1) = 3*abs(result.branch(ii,14));
        capacityVector(ii,1) = missingCapacityValue; 
    end
end
mpc.branch(:,6) = capacityVector;
end

function adjacencyMatrix = getAdjacencyMatrix(mpc)
branch = mpc.branch;
adjacencyMatrix = zeros(size(mpc.bus,1));
for ii = 1:size(branch,1)
    adjacencyMatrix(branch(ii,1), branch(ii,2)) = 1;
    adjacencyMatrix(branch(ii,2), branch(ii,1)) = 1;
end
adjacencyMatrix = sparse(adjacencyMatrix);
end
